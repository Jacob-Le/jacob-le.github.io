<!DOCTYPE html>
<html lang="en">

<head>
    <title>HW3 - Assignment B</title>
    <meta charset="utf-8">
    <style>
        body {
            margin: 0px;
            overflow: hidden;
        }
    </style>
</head>

<body>
    <div id="container"></div>

    <script src="./js/three.js"></script>

    <script id="vertexShader" type="x-shader/x-vertex">

            //Three.js gives us these automatically when a perspective camera is bound to the renderer
            uniform mat4 modelMatrix;
	        uniform mat4 viewMatrix;
      	    uniform mat4 projectionMatrix;

            attribute vec3 position;
	        attribute vec2 uv;
	        attribute vec3 normal;

            precision mediump float;

            void main() {

                gl_Position = projectionMatrix  * viewMatrix * modelMatrix  * vec4( position, 1.0 );
		
     	    }

        </script>

    <script id="fragmentShader" type="x-shader/x-fragment">
            precision mediump float;

            const int MAX_MARCHING_STEPS = 255;
            const float MIN_DIST = 0.0;
            const float MAX_DIST = 100.0;
            const float EPSILON = 0.0001;

            uniform vec2 u_resolution;
            uniform float iTime;
            
            /**
            * Signed distance function for a sphere centered at the origin with radius 1.0;
            */
            float sphereSDF(vec3 samplePoint) {
                return length(samplePoint) - 1.0;
            }
            
            // SDF for intersecting shapes (n)/(or)
            float intersectSDF(float distA, float distB){
                return max(distA, distB);
            }

            // SDF for union between shapes (u)/(and)
            float unionSDF(float distA, float distB){
                return min(distA, distB);
            }

            // SDF for difference between shapes (xor)
            float differenceSDF(float distA, float distB){
                return max(distA, -distB);
            }

            /**
            * Absolute value of the return value indicates the distance to the surface.
            * Sign indicates whether the point is inside or outside the surface,
            * negative indicating inside.
            */
            float sceneSDF(vec3 samplePoint) {
                return sphereSDF(samplePoint);
            }
            
            /**
            * Return the shortest distance from the eyepoint to the scene surface along
            * the marching direction. If no part of the surface is found between start and end,
            * return end.
            * 
            * eye: the eye point, acting as the origin of the ray
            * marchingDirection: the normalized direction to march in
            * start: the starting distance away from the eye
            * end: the max distance away from the ey to march before giving up
            */
            float shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {
                float depth = start;
                for (int i = 0; i < MAX_MARCHING_STEPS; i++) {
                    float dist = sceneSDF(eye + depth * marchingDirection);
                    if (dist < EPSILON) {
                        return depth;
                    }
                    depth += dist;
                    if (depth >= end) {
                        return end;
                    }
                }
                return end;
            }    
            
            /**
            * Return the normalized direction to march in from the eye point for a single pixel.
            * 
            * fieldOfView: vertical field of view in degrees
            * size: resolution of the output image
            * fragCoord: the x,y coordinate of the pixel in the output image
            */
            vec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {
                vec2 xy = fragCoord - size / 2.0;
                float z = size.y / tan(radians(fieldOfView) / 2.0);
                return normalize(vec3(xy, -z));
            }
            
            /**
            * Using the gradient of the SDF, estimate the normal on the surface at point p.
            */
            vec3 estimateNormal(vec3 p) {
                return normalize(vec3(
                    sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),
                    sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),
                    sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))
                ));
            }
            
            /**
            * Lighting contribution of a single point light source via Phong illumination.
            * 
            * The vec3 returned is the RGB color of the light's contribution.
            *
            * k_a: Ambient color
            * k_d: Diffuse color
            * k_s: Specular color
            * alpha: Shininess coefficient
            * p: position of point being lit
            * eye: the position of the camera
            * lightPos: the position of the light
            * lightIntensity: color/intensity of the light
            */
            vec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,
                                        vec3 lightPos, vec3 lightIntensity) {
                vec3 N = estimateNormal(p);
                vec3 L = normalize(lightPos - p);
                vec3 V = normalize(eye - p);
                vec3 R = normalize(reflect(-L, N));
                
                float dotLN = dot(L, N);
                float dotRV = dot(R, V);
                
                if (dotLN < 0.0) {
                    // Light not visible from this point on the surface
                    return vec3(0.0, 0.0, 0.0);
                } 
                
                if (dotRV < 0.0) {
                    // Light reflection in opposite direction as viewer, apply only diffuse
                    // component
                    return lightIntensity * (k_d * dotLN);
                }
                return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));
            }
            
            /**
            * Lighting via Phong illumination.
            * 
            * The vec3 returned is the RGB color of that point after lighting is applied.
            * k_a: Ambient color
            * k_d: Diffuse color
            * k_s: Specular color
            * alpha: Shininess coefficient
            * p: position of point being lit
            * eye: the position of the camera
            */
            vec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {
                const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);
                vec3 color = ambientLight * k_a;
                
                vec3 light1Pos = vec3(4.0 * sin(iTime),
                                        2.0,
                                        4.0 * cos(iTime));
                vec3 light1Intensity = vec3(0.4, 0.4, 0.4);
                
                color += phongContribForLight(k_d, k_s, alpha, p, eye,
                                                light1Pos,
                                                light1Intensity);
                
                vec3 light2Pos = vec3(2.0 * sin(0.37 * iTime),
                                        2.0 * cos(0.37 * iTime),
                                        2.0);
                vec3 light2Intensity = vec3(0.4, 0.4, 0.4);
                
                color += phongContribForLight(k_d, k_s, alpha, p, eye,
                                                light2Pos,
                                                light2Intensity);    
                return color;
            }
            
            
            void main()
            {
                vec3 dir = rayDirection(45.0, u_resolution.xy, gl_FragCoord);
                vec3 eye = vec3(0.0, 0.0, 5.0);
                float dist = shortestDistanceToSurface(eye, dir, MIN_DIST, MAX_DIST);
                //Insert intersect/union/difference here
                
                if (dist > MAX_DIST - EPSILON) {
                    // Didn't hit anything
                    gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
                    return;
                }
                
                // The closest point on the surface to the eyepoint along the view ray
                vec3 p = eye + dist * dir;
                
                vec3 K_a = vec3(0.2, 0.2, 0.2);
                vec3 K_d = vec3(0.7, 0.2, 0.2);
                vec3 K_s = vec3(1.0, 1.0, 1.0);
                float shininess = 10.0;
                
                vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);
                
                gl_FragColor = vec4(color, 1.0);
            }
        </script>

    <script>
        var container;

        var camera, scene, renderer, mesh;

        var vs = document.getElementById('vertexShader').textContent;
        var fs = document.getElementById('fragmentShader').textContent;

        var mouseX = 0.0;
        var mouseY = 0.0;

        init();
        animate();

        function init() {
            container = document.getElementById('container');

            var width = window.innerWidth;
            var height = window.innerHeight;

            camera = new THREE.OrthographicCamera(width / -2, width / 2, height / 2, height / -2, 0.1, 1000);
            camera.position.z = 10;

            scene = new THREE.Scene();

            // geometry

            var geometry = new THREE.PlaneGeometry(width, height, 1, 1);

            // material

            var uniforms = {
                u_resolution: { type: "v2", value: new THREE.Vector2(width, height) },

            };

            var material = new THREE.RawShaderMaterial({

                uniforms: uniforms,
                vertexShader: vs,
                fragmentShader: fs,

            });

            mesh = new THREE.Mesh(geometry, material);
            scene.add(mesh);


            renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            container.appendChild(renderer.domElement);


            window.addEventListener('resize', onWindowResize, true);

        }

        function onWindowResize(event) {

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);
            mesh.material.uniforms.u_resolution.value = new THREE.Vector2(window.innerWidth, window.innerHeight);
        }

        function animate() {

            requestAnimationFrame(animate);
            render();

        }

        function render() {


            renderer.render(scene, camera);
        }
    </script>
</body>

</html>